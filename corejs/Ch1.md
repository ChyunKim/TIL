# 데이터 타입
데이터 타입에는 크게 두가지로 기본형, 참조형이 있습니다.

## 데이터 타입 종류

**- 기본형 : Number, String, Boolean, Null, Undefined, Symbol**
**- 참조형 : Object, Array, Function**

데이터 타입은 기본형과 참조형으로 나눌수 있습니다.

이렇게 나누는 기준은 기본형은 값이 담긴 주솟값을 바로 복제하며 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제합니다.

위의 말을 이해하기 위해서는 변수를 선언하고 데이터를 어떻게 할당받는지 알아봅시다.

## 변수선언과 데이터 할당

```javascript
let a;
```
변수선언은 위와 같이 선언할 수 있으며 선언과 동시에 데이터를 할당받을 수 있습니다.

```javascript
let a = 'abc';
```

위와 같이 문자열 'abc'를 a 변수에 할당하게 되었습니다.

```a = 'abc'``` 식을 통해 우리는 a라는 변수에 'abc'를 직접 대입한다고 이해할 수 있지만 컴퓨터는 해당 데이터를 a와 'abc' 각각의 메모리 공간에 배정하게 됩니다.

![](https://velog.velcdn.com/images/chyun10/post/03f83a8b-3046-4874-ba6e-b69c5958325f/image.png)

위의 그림과 같이 변수영역과 데이터영역은 각각의 메모리 공간을 갖게 되며
변수 a는 데이터영역의 주소값을 가리키게 됩니다.

```javascript
let a = 5;
let b = 5;
console.log(a===b);		//true
```

위와 같이 선언되었다면 각각의 변수 a,b는 어떤 주소값을 가지게 될까요?
변수 a,b는 같은 값을 가지고 있으므로 5의 주소값을 가리키게 됩니다.

**그렇다면 값을 변수에 직접 대입하지 않고 이렇게 변수 영역과 데이터 영역의 메모리를 나눠어 할당하는 이유는 무엇일까요?**

바로, 데이터 변환을 자유롭게 할 수 있음과 동시에 메모리를 더욱 효율적으로 관리하기 위함입니다.

변수에 값을 직접 대입한다면 a와 b은 동일한 값을 갖지만 각각의 공간을 보유하게 됩니다.

또한, 값이 변경되면 메모리 공간을 늘리거나 줄이는 별도의 작업이 필요로 하게 됩니다.

결국은 컴퓨터가 처리하게 될 연산이 많아지게 되니 효율적으로 처리하기 어렵게 됩니다.

**이렇게, 메모리 공간을 분리하면 중복된 데이터에 대한 처리 효율이 높아지게 됩니다.
**

## 기본형데이터와 참조형 데이터
### 불변값 
- 변경은 새로 만드는 동작을 통해서만 이뤄집니다.
- 기본형 데이터는 모두 불변값입니다.

예를 들어 알아봅시다.

```javascript
let a = 'abc'
a = a + 'ab'

let b = 7;
let c = 7;
console.log(b===c);		//true
c = 5;
console.log(b===c);		//false
```

위와 같은 주소값을 갖는 상황에서 ```a = a + 'ab'``` 와 ```c = 5``` 가 대입되면 어떻게 주소값이 바뀔까요?

기존 ```a = 'abc'``` 대입되어 있었기에 기존 메모리를 활용한다고 생각할 수 있습니다. 하지만 ```'ab'```를 추가하기 위해 새로운 메모리 공간에 새로운 문자열을 만들어 저장하게 됩니다.

별도의 메모리 공간에 ```'abcab'```라는 문자열을 새롭게 만들고 a는 새로운 주소값을 가리키게 됩니다.

물론 c의 값도 5로 변경되었기 때문에 5의 메모리 공간 주소값을 가리키게 됩니다.

이처럼 변경되는 값을 변경하는 것이 아닌 새로운 메모리로 만들어 지게 됩니다.

### 가변값
- 기본형 데이터와의 차이는 객체의 변수(프로퍼티) 영역이 별도로 존재한다는 것입니다.
- 데이터 영역에 저장된 값은 모두 불변값입니다. 바뀌는 것은 객체의 변수영역의 값이 변경되는 것입니다.

예를 들어 확인해봅시다.

```javascript
let a = 5;
let b = a;
let obj = { c: 5, d: '123' }
let obj2 = obj;
    
b = 10;
obj.c = 15;
```
기본형 데이터는 불변값으로 데이터의 주소만 복사해오는 것이라 앞서 설명을 드렸습니다. 따라서 b = 10 이후에도 a 값에는 변함이 없습니다.

하지만 가변값이 obj는 obj2 = obj; 이후의 두 값이 가리키는 참조값은 같아지며 obj 에서 프로퍼티를 변경하든, obj2 에서 프로퍼티를 변경하든 두 값은 서로 영향을 미치게 됩니다.

이렇게 값이 변경되면 '새로운 객체'가 만들어지는 것이 아닌 기존 객체의 내부의 값이 바뀌게 됩니다.

## 불변객체
그렇다면 참조형 데이터의 가변은 데이터 자체가 아닌 내부 프로퍼티를 변경하기 때문에 데이터 자체를 변경하고자 할때 문제가 발생합니다.

내부 프로퍼티를 변경할 필요가 있을때마다 매번 새로운 객체를 만들어 재할당해야할 것입니다.

이런 상황에서 불변객체가 필요로 합니다.

### 얇은 복사
얇은 복사는 바로 아래 단계의 값만 복사하는 방법입니다.

```javascript
let copy = function(Obj) {
 	let result = {};
  	for(var prop in Obj) {
      		result[prop] = Obj[prop];
    }
}
```
위와 같이 대상 객체의 프로퍼티 개수와 상관없으 모든 프로퍼티를 복사할 수 있습니다.

하지만 이러한 복사는 객체 내부의 참조형 데이터가 있을 시 문제가 발생하게 됩니다. 

얇은 복사는 객체 내부 모든 값을 복사하지 않기 때문입니다.
객체 내부 참조형 데이터가 저장된 프로퍼티를 복사할때 그 주솟값만 복사합니다.

그러면 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 되며 사본이 바뀌면 원본도 바뀌는 문제가 발생합니다.

### 깊은복사
깊은 복사는 내부의 모든값들을 하나하나 찾아서 전부 복사하는 방법입니다.
얇은 복사의 문제를 해결할 수 있게 됩니다.

객체 내부 참조형 데이터가 저장된 프로퍼티도 복사하기 때문에 사본이 바뀌어도 원본이 바뀌는 문제가 없습니다.



