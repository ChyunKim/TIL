// 스코프 (Scope)
// 유효범위
// 함수의 매개변수는 함수 몸체 내부에서만 참조할 수 있고 외부에서는 참조할 수 없음 => 이것은 매개변수를 참조할 수 있는 유효범위 = 매개변수의 스코프
function add(a, b) {
    console.log(a, b)
    return a+b
}

add(1,3)
console.log(a,b)                // 함수 외부에서 참조시 ReferenceError



// 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정됨
// 스코프는 식별자가 유효한 범위를 뜻함
var var1 = 1;

if(true) {                      // 코드 블럭내 선언한 변수
    var var2 = 2
    if(true){
        var var3 = 3
    }
}

function foo() {                // 함수 내에서 선언한 변수
    var var4 = 4;

    function bar() {
        var var5 = 5;
    }
}

console.log(var1);              // 1
console.log(var2);              // 2
console.log(var3);              // 3 
console.log(var4);              // ReferenceError
console.log(var5);              // ReferenceError


// 지역스코프
// 지역은 함수 몸체 내부를 뜻하며 지역은 지역 스코프를 만듬 => 지역변수는 자신이 선언된 지역과 하위지역(중첩함수) 에서만 참조가능

// 함수 레벨 스코프
// var 키워드로 선언된 변수는 함수의 코드 블록만들 지역 스코프로 인정
var x = 1;

if(true) {
    /*
        var 키워드로 선언된 변수는 함수의 코드블록만들 지역 스코프로 인정
        함수 밖에서 var 키워드로 선언된 변수는 코드 블록내에서 선언되었다 할지라도 모두 전역변수
        따라서 x는 전역변수이며 이미 선언된 전역 변수 x 가 있으므로 x 변수는 중복 선언
        이는 의도치 않게 변수 값이 변경되느 부작용 발생
    */
    var x = 10
}

console.log(x);                 // 10


// for문 역시 블록내에서 선언되었다 할지라도 모두 전역변수로 취급
var i = 0;

for(var i = 0; i < 5; i++) {
    console.log(i);
}

// for문 에서 전역변수로 취급되는 i를 증감했기 때문에 블록밖에서도 i는 증가한 값을 갖음
console.log(i);                // 5



// 렉시컬 스코프
var x = 1;
function foo() {
    var x = 10;
    bar();
}

function bar() {
    console.log(x);             // 1
}

foo();                          // 1
bar();

/*
    위 코드의 실행 결과는 bar 함수의 상위 스코프가 무엇인지에 따라 결정된다.
    1. 함수를 어디서 호출 했는지에 따라 함수의 상위 스코프를 결정
    2. 함수를 어디서 정의 했는지에 따라 함수의 상위 스코프 결정

    1번째 방식을 동적 스코프라 하며 함수를 정의하는 시점에서 함수가 어디서 호출될 지 알 수 없다.
    따라서 함수가 호출되는 시멎에 동적으로 상위 스코프를 결정하기 때문에 동적 스포프라 부른다.

    2번째 방식은 렉시컬 스코프 = 정적스코프라 한다.
    동적 스코프 방식처럼 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.

    "자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다"
*/




