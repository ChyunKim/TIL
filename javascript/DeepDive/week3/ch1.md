# 데이터 타입
데이터 타입에는 크게 두가지로 기본형, 참조형이 있음<br>

## 데이터 타입 종류<br>

- 기본형 : Number, String, Boolean, Null, Undefined, Symbol<br>
- 참조형 : Object, Array, Function<br>

데이터 타입은 기본형과 참조형<br>
기본형은 값이 담긴 주솟값을 바로 복제하며 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제<br><br>

## 변수선언과 데이터 할당<br>

```javascript
let a;
```
변수선언은 위와 같이 선언할 수 있으며 선언과 동시에 데이터를 할당<br>

```javascript
let a = 'abc';
```

위와 같이 문자열 'abc'를 a 변수에 할당<br>

```a = 'abc'``` 식을 통해 우리는 a라는 변수에 'abc'를 직접 대입한다고 이해할 수 있지만, <br>
컴퓨터는 해당 데이터를 a와 'abc' 각각의 메모리 공간에 배정<br><br>

변수 a는 데이터영역의 주소값을 가리키게 됨<br>

```javascript
let a = 5;
let b = 5;
console.log(a===b);		//true
```
위와 같이 선언되었다면 가정<br>
변수 a,b는 같은 값을 가지고 있으므로 5의 주소값을 가리키게 됨<br><br>

**그렇다면 값을 변수에 직접 대입하지 않고 이렇게 변수 영역과 데이터 영역의 메모리를 나눠어 할당하는 이유?**<br>

바로, 데이터 변환을 자유롭게 할 수 있음과 동시에 메모리를 더욱 효율적으로 관리하기 위한 목적<br>
변수에 값을 직접 대입한다면 a와 b은 동일한 값을 갖지만 각각의 공간을 보유하게 됨<br>
또한, 값이 변경되면 메모리 공간을 늘리거나 줄이는 별도의 작업이 필요로 하게됨<br>
결국은 컴퓨터가 처리하게 될 연산이 많아지게 되니 효율적으로 처리하기 어렵게 됨<br><br>

**이렇게, 메모리 공간을 분리하면 중복된 데이터에 대한 처리 효율이 높아짐**<br>

## 기본형데이터와 참조형 데이터
### (1) 불변값 
- 변경은 새로 만드는 동작을 통해서만 이뤄짐<br>
- 기본형 데이터는 모두 불변값<br>


```javascript
let a = 'abc'
a = a + 'ab'

let b = 7;
let c = 7;
console.log(b===c);		//true
c = 5;
console.log(b===c);		//false
```

기존 ```a = 'abc'``` 대입되어 있었기에 기존 메모리를 활용한다고 생각할 수 있지만, <br>
```'ab'```를 추가하기 위해 새로운 메모리 공간에 새로운 문자열을 만들어 저장<br><br>
별도의 메모리 공간에 ```'abcab'```라는 문자열을 새롭게 만들고 a는 새로운 주소값을 가리키게 됨<br>
물론 c의 값도 5로 변경되었기 때문에 5의 메모리 공간 주소값을 가리키게 됨<br><br>
이처럼 변경되는 값을 변경하는 것이 아닌 새로운 메모리로 만듬<br>

### (2) 가변값
- 기본형 데이터와의 차이는 객체의 변수(프로퍼티) 영역이 별도로 존재<br>
- 데이터 영역에 저장된 값은 모두 불변값입니다. 바뀌는 것은 객체의 변수영역의 값이 변경<br>

```javascript
let a = 5;
let b = a;
let obj = { c: 5, d: '123' }
let obj2 = obj;
    
b = 10;
obj.c = 15;
```
```b = 10``` 이후에도 ```a``` 값에는 변함이 없음<br>
하지만 가변값이 obj는 obj2 = obj; 이후의 두 값이 가리키는 참조값은 같아지며,<br>
obj 에서 프로퍼티를 변경하든, obj2 에서 프로퍼티를 변경하든 두 값은 서로 영향을 미침<br><br>
이렇게 값이 변경되면 '새로운 객체'가 만들어지는 것이 아닌 기존 객체의 내부의 값이 바뀌게 됨<br><br>

## 불변객체<br>
참조형 데이터의 가변은 데이터 자체가 아닌 내부 프로퍼티를 변경하기 때문에 데이터 자체를 변경하고자 할때 문제가 발생<br>
내부 프로퍼티를 변경할 필요가 있을때마다 매번 새로운 객체를 만들어 재할당해야 함<br>

이런 상황에서 불변객체가 필요<br><br>

### (1) 얇은 복사<br>
얇은 복사는 바로 아래 단계의 값만 복사하는 방법<br>

```javascript
let copy = function(Obj) {
 	let result = {};
  	for(var prop in Obj) {
      result[prop] = Obj[prop];
    }
}
```
위와 같이 대상 객체의 프로퍼티 개수와 상관없으 모든 프로퍼티를 복사<br>
하지만 이러한 복사는 객체 내부의 참조형 데이터가 있을 시 문제가 발생<br><br>
얇은 복사는 객체 내부 모든 값을 복사하지 않기 때문<br>
객체 내부 참조형 데이터가 저장된 프로퍼티를 복사할때 그 주솟값만 복사<br><br>
그러면 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 되며 사본이 바뀌면 원본도 바뀌는 문제가 발생<br><br>

### (2) 깊은복사<br>
깊은 복사는 내부의 모든값들을 하나하나 찾아서 전부 복사하는 방법<br>
얇은 복사의 문제를 해결 가능<br><br>
```javascript
let copyObj = function(target) {
  let result = {}
  if(typeof target === 'object' ** target !== null) {
    for(var prop in target) {
      retuls[prop] = copyObj(target[prop])
    }
  }else {
      result = target
  }
  return result;
}
```
위와 같이 ```target``` 이 객체인 경우 내부 프로퍼티를 순회하며 ```copyObj``` 재귀적으로 호출하여 객체를 참조하도록 가능<br> 
객체 내부 참조형 데이터가 저장된 프로퍼티도 복사하기 때문에 사본이 바뀌어도 원본이 바뀌는 문제가 발생하지 않음<br>


